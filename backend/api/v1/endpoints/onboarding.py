import asyncio
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import APIRouter, Depends, HTTPException
from backend.models.goal import Goal
from backend.core.database import get_db
from backend.core.security import create_access_token, verify_google_token_header
from backend.models.student import Student
from backend.models.objective import Objective
from backend.repositories.student_repository import StudentRepository
from backend.services.gemini.onboarding.schema import GeminiGoalValidation, GeminiFollowUpValidation
from backend.services.gemini.onboarding.onboarding import get_gemini_follow_up_questions, get_gemini_study_plan
from backend.services.gemini.onboarding.goal_validation import get_prompt_validation, get_follow_up_validation, isGoalValidated, isFollowUpValidated
from backend.schemas.student import TokenResponse
from backend.schemas.goal import GoalCreationFollowUpQuestionsRequest, GoalCreationFollowUpQuestionsResponse, GoalStudyPlanRequest, GoalStudyPlanResponse, GoalFullCreationRequest
from backend.utils.gemini.gemini_configs import get_gemini_embeddings

router = APIRouter()

@router.post(
    "/follow_up_questions",
    status_code=201,
    response_model=GoalCreationFollowUpQuestionsResponse,
    description="Initiate the onboarding process by analyzing the user's goal prompt and generating follow-up questions.")
async def generate_follow_up_questions(
    request: GoalCreationFollowUpQuestionsRequest,
    #user_info: dict = Depends(verify_google_token_header)
):
        
    validation: GeminiGoalValidation = get_prompt_validation(request)
    is_validated: bool = isGoalValidated(validation)
    
    if not is_validated:
        raise HTTPException(status_code=400, detail=validation.reasoning)
    
    return get_gemini_follow_up_questions(request)

@router.post(
    "/study_plan",
    status_code=201,
    response_model=GoalStudyPlanResponse,
    description="Receive the Study Plan generated by the AI.")
async def generate_study_plan(
    request: GoalStudyPlanRequest,
    #user_info: dict = Depends(verify_google_token_header)
):
    
    validation: GeminiFollowUpValidation = get_follow_up_validation(request)
    is_validated: bool = isFollowUpValidated(validation)
    
    if not is_validated:
        raise HTTPException(status_code=400, detail=validation.reasoning)
    
    return get_gemini_study_plan(request)

@router.post(
    "/full_creation",
    status_code=201,
    response_model=TokenResponse,
    description="Create user account and complete onboarding with goal and objective.")
async def generate_full_creation(
    request: GoalFullCreationRequest,
    user_info: dict = Depends(verify_google_token_header),
    db: AsyncSession = Depends(get_db)
):
    
    try:
        student_repo = StudentRepository(db)
        existing_user = await student_repo.get_by_google_id(user_info["sub"])
        
        if existing_user:
            raise HTTPException(status_code=409,detail="User already exists")
        
        goal = Goal(
            name=request.goal_name,
            description=request.goal_description,
        )
        
        db.add(goal)
        await db.commit()
        await db.refresh(goal)
        
        objective = Objective(
            goal_id=goal.id,
            name=request.first_objective_name,
            description=request.first_objective_description
        )
        
        db.add(objective)
        await db.commit()
        await db.refresh(objective)
        
        user = Student(
            email=user_info["email"],
            google_id=user_info["sub"],
            name=user_info.get("name"),
            goal_id=goal.id,
            goal_name=goal.name,
            current_objective_id=objective.id,
            current_objective_name=objective.name,
        )
        created_user = await student_repo.create(user)
        
        asyncio.create_task(
            save_description_embeddings_async(goal, objective, db)
        )
        
        access_token = create_access_token(data={"sub": created_user.google_id})
        
        await db.commit()
        
        return TokenResponse(
            access_token=access_token,
            student=created_user
        )
        
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        raise HTTPException(
            status_code=500,
            detail="Internal server error"
        )

async def save_description_embeddings_async(goal: Goal, objective: Objective, db: AsyncSession):
    goal_description_embedding = get_gemini_embeddings(goal.description)
    objective_description_embedding = get_gemini_embeddings(objective.description)
    goal.description_embedding = goal_description_embedding
    objective.description_embedding = objective_description_embedding
    await db.commit()
    await db.refresh(goal)
    await db.refresh(objective)