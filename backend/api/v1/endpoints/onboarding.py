import asyncio
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import APIRouter, Depends, HTTPException, status
from backend.models.goal import Goal
from backend.core.database import get_db
from backend.core.security import create_access_token, verify_google_token_header
from backend.models.student import Student
from backend.models.objective import Objective
from backend.repositories.student_repository import StudentRepository
from backend.services.gemini.onboarding.schema import GeminiGoalValidation, GeminiFollowUpValidation
from backend.services.gemini.onboarding.onboarding import get_gemini_follow_up_questions, get_gemini_study_plan
from backend.services.gemini.onboarding.goal_validation import get_prompt_validation, get_follow_up_validation, isGoalValidated, isFollowUpValidated
from backend.schemas.student import TokenResponse, StudentResponse
from backend.schemas.goal import GoalCreationFollowUpQuestionsRequest, GoalCreationFollowUpQuestionsResponse, GoalStudyPlanRequest, GoalStudyPlanResponse, GoalFullCreationRequest
from backend.utils.gemini.gemini_configs import get_gemini_embeddings
from backend.services.account_creation_tasks import account_creation_tasks

router = APIRouter()

@router.post(
    "/follow_up_questions",
    status_code=201,
    response_model=GoalCreationFollowUpQuestionsResponse,
    description="Initiate the onboarding process by analyzing the user's goal prompt and generating follow-up questions.")
async def generate_follow_up_questions(
    request: GoalCreationFollowUpQuestionsRequest,
    user_info: dict = Depends(verify_google_token_header)
):
        
    validation: GeminiGoalValidation = get_prompt_validation(request)
    is_validated: bool = isGoalValidated(validation)
    
    if not is_validated:
        raise HTTPException(status_code=400, detail=validation.reasoning)
    
    return get_gemini_follow_up_questions(request)

@router.post(
    "/study_plan",
    status_code=201,
    response_model=GoalStudyPlanResponse,
    description="Receive the Study Plan generated by the AI.")
async def generate_study_plan(
    request: GoalStudyPlanRequest,
    user_info: dict = Depends(verify_google_token_header)
):
    
    validation: GeminiFollowUpValidation = get_follow_up_validation(request)
    is_validated: bool = isFollowUpValidated(validation)
    
    if not is_validated:
        raise HTTPException(status_code=400, detail=validation.reasoning)
    
    return get_gemini_study_plan(request)

@router.post(
    "/full_creation",
    status_code=201,
    response_model=TokenResponse,
    description="Complete onboarding by creating a goal and objective. Account must already exist.")
async def generate_full_creation(
    request: GoalFullCreationRequest,
    user_info: dict = Depends(verify_google_token_header),
    db: AsyncSession = Depends(get_db)
):
    
    try:
        student_repo = StudentRepository(db)
        user = await student_repo.get_by_google_id(user_info["sub"])
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User account not found. Please sign up first."
            )
        
        # Create goal with student_id
        goal = Goal(
            student_id=user.id,
            name=request.goal_name,
            description=request.goal_description,
        )
        
        db.add(goal)
        await db.commit()
        await db.refresh(goal)
        
        # Store goal ID immediately after refresh to avoid async issues
        goal_id = goal.id
        
        # Create objective
        objective = Objective(
            goal_id=goal_id,
            name=request.first_objective_name,
            description=request.first_objective_description,
            ai_model="gemini-2.5-flash"
        )
        
        db.add(objective)
        await db.commit()
        await db.refresh(objective)
        
        # Store objective ID immediately after refresh to avoid async issues
        objective_id = objective.id
        
        # Update student's active goal and objective
        # Use request values directly to avoid any async ORM attribute access issues
        user.goal_id = goal_id
        user.goal_name = request.goal_name
        user.current_objective_id = objective_id
        user.current_objective_name = request.first_objective_name
        
        await student_repo.update(user)
        
        # Save description embeddings
        await save_description_embeddings_async(goal, objective, db)
        
        # Generate JWT access token
        access_token = create_access_token(data={"sub": user.google_id})
        
        await db.commit()
        
        # Trigger async account creation tasks (MCQs, notes, resources, student context)
        # These run in the background with a new database session
        # Note: onboarding_prompt and questions_answers are None since GoalFullCreationRequest
        # doesn't include them. This can be enhanced later by adding them to the request schema.
        async def run_account_creation_tasks():
            from backend.core.database import AsyncSessionLocal
            async with AsyncSessionLocal() as new_db:
                try:
                    await account_creation_tasks(
                        student=user,
                        goal=goal,
                        objective=objective,
                        db=new_db,
                        onboarding_prompt=None,
                        questions_answers=None
                    )
                except Exception as e:
                    # Log error but don't fail the request
                    import logging
                    logger = logging.getLogger(__name__)
                    logger.error(f"Error in background account creation tasks: {e}", exc_info=True)
        
        asyncio.create_task(run_account_creation_tasks())
        
        student_response = StudentResponse(
            id=str(user.id),
            google_id=user.google_id,
            email=user.email,
            name=user.name
        )
        
        return TokenResponse(
            access_token=access_token,
            student=student_response
        )
        
    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Error in generate_full_creation: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail="Internal server error"
        )

async def save_description_embeddings_async(goal: Goal, objective: Objective, db: AsyncSession):
    goal_description_embedding = get_gemini_embeddings(goal.description)
    objective_description_embedding = get_gemini_embeddings(objective.description)
    goal.description_embedding = goal_description_embedding
    objective.description_embedding = objective_description_embedding
    await db.commit()
    await db.refresh(goal)
    await db.refresh(objective)
